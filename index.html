<!DOCTYPE html>
<html>
<head>
    <title>Chart.js-Multi line charts </title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
</head>
<body>
    <div style="margin-left:5%;margin-right:5%">
        <canvas id="myLineChart" style="width:100%;max-width:1800px"></canvas>
    </div>

    <input type="file" name="inputfile"
            id="inputfile">
    <br>

    <input type="file" name="inputfile1"
            id="inputfile1">
    <br>

    <pre id="output"></pre>


    <script>
        let xValues = [2011, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014, 2016,
					2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022,
					2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022];

		// let data1 = [100, 500, 600, 800, 700, 900, 1200, 850, 970, 750, 1100, 100, 500, 600, 800, 700, 900, 1200, 850, 970, 750, 1100];
        let data1 = [];
		let data2 = [98, 450, 750, 900, 650, 988, 1550, 880, 600, 800, 1300];
		let data3 = [88, 800, 450, 550, 350, 820, 620, 730, 740, 660, 669];

        const  MultiLinechartData = {
            type: "line",
            data: {
                labels: xValues,
                datasets: [
                    {
                        label: 'JavaScript Developer',
                        lineTension: 0,
                        backgroundColor: 'blue',
                        borderColor: 'blue',
                        data: data1
                    },
                    {
                        label: 'React Developer',
                        lineTension: 0,
                        borderColor: 'green',
                        data: data2
                    },
                    {
                        label: 'Chart Js Developer',
                        lineTension: 0,
                        borderColor: 'red',
                        data: data3
                    }
                ]
            },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: 'Software developers in organization',
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: 'Counts'
                        }
                    }
                }
            }
        };

        // document.getElementById('inputfile1').onclick = function(){
        //     // alert('Test...');
        //     var file = this.files[0];
        //     var reader = new FileReader();
        //     reader.onload = function(progressEvent){
        //         var fileContentArray = this.result.split(/\r\n|\n/);
        //         var lines = fileContentArray;
        //         for(var line = 0; line < lines.length-1; line++){
        //         console.log(line + " --> "+ lines[line]);
        //         }
        //     };
        //     reader.readAsText(file);
        // };


		document.getElementById('inputfile')
			.addEventListener('change', async function() {
                let fr=new FileReader();
                fr.onload=function(){
                    document.getElementById('output').textContent=fr.result;
                    console.log(fr.result.length);
                    data1 = [];
                    data2 = [];
                    xValues = [];
                    // console.log(this.result);
                    var fileContentArray = this.result.trim().split(/\r\n|\n/);
                    var lines = fileContentArray;
                    let tempstr = '';
                    let rfidarray = []; //rfid data from reader, 整理一次讀取只有RFID數據
                    console.log('lines.length=' + lines.length );
                    lines.forEach(function(valstr, index, arr) {
                        // console.log(index + " --> "+ valstr.slice(53));
                        if (valstr.slice(53).includes('@END')) { //讀取結束

                            console.log('rfidarray.length=' + rfidarray.length );
                            if( rfidarray.length > 0)
                            {
                                let rfidsoled = rfidsole(rfidarray);
                                console.log(rfidsoled[0].COUNT);
                                if( rfidsoled.length === 2)
                                {
                                    console.log( 'rfidsoled[1]:' +  rfidsoled[1].COUNT);
                                    data2.push(rfidsoled[1].COUNT);

                                }
                                else{
                                    data2.push(0);
                                }

                                data1.push(rfidsoled[0].COUNT);
                                xValues.push(rfidsoled[0].TIME.slice(11) );

                            }
                            else{
                                let rfidsoled = [];
                                let rfid = { //Save RFID format
                                    EPC: '',
                                    TID: '',
                                    TIME: '',
                                    COUNT: 0
                                };

                                rfid.EPC = '';
                                // console.log(rfid.EPC);
                                rfid.TIME = valstr.slice(1,24);
                                // console.log(rfid.TIME);
                                rfidsoled.push(rfid);
                                // console.log(rfidsoled[0].COUNT);
                                data1.push(rfidsoled[0].COUNT);
                                data2.push(0);
                                xValues.push(rfidsoled[0].TIME.slice(11) );
                            }
                            rfidarray = []; //Reset array

                        }
                        else{
                            let rfid = { //Save RFID format
                                EPC: '',
                                TID: '',
                                TIME: '',
                                COUNT: 0
                            };

                            rfid.EPC = valstr.slice(53);
                            // console.log(rfid.EPC);
                            rfid.TIME = valstr.slice(1,24);
                            // console.log(rfid.TIME);
                            rfidarray.push(rfid);
                        }

                    });
                    console.log("myLineChart");
                    // console.log(data1);
                    MultiLinechartData.data.datasets[0].data = data1;
                    MultiLinechartData.data.datasets[1].data = data2;
                    MultiLinechartData.data.datasets[2].data = '';
                    MultiLinechartData.data.labels = xValues;
                    console.log(MultiLinechartData.data.datasets[0].data);
                    console.log(MultiLinechartData.data.labels);
                    let mychart = new Chart("myLineChart", MultiLinechartData );
                    console.log(MultiLinechartData);
                    // for(var line = 0; line < lines.length-1; line++){
                    //     console.log(line + " --> "+ lines[line]);
                    // }
                }
                await fr.readAsText(this.files[0]);

		});

        let rfidsole = function(rfid) {
            var len = rfid.length;
            let rfidres = [];
            let rfidarrayrecsort = [];
            let foundindex = -1;

            var sid = rfid.filter(function(ele, pos) {
                // LoggerRFID.trace('rfidsole: ' + ele.EPC + ',' + pos + ',' + rfid.indexOf(ele.EPC));
                var index;
                for (let i = 0; i < rfid.length; i++) {
                    // console.log(ele.EPC + '  :  ' + rfid[i].EPC);
                    if (ele.EPC === rfid[i].EPC) {
                        index = i;
                        break;
                    }
                }
                // console.log(index);
                return index == pos; //只找第一次出現的
            });

            // console.log(sid);

            //Count
            sid.forEach(elem => {
                for (let i = 0; i < rfid.length; i++) {
                    if (elem.EPC == rfid[i].EPC) {
                        elem.COUNT++;
                    }
                }
            });

            sid.sort(function(a, b) {
                return b.COUNT - a.COUNT;
            })

            // console.trace(sid);
            // console.trace('sid.length= ' + sid.length);
            console.log('sid.length= ' + sid.length);
            // console.log(sid);
            return sid;
        }

    </script>

</body>
</html>
