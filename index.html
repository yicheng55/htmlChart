<!DOCTYPE html>
<html>

<head>
    <title>Chart.js-Multi line charts</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
    <script src="js/chart.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            height: 90%;
            overflow: auto;
        }
        /* #large-container {
            width: 2000px;
            height: 800px;
            overflow: hidden;
        } */
        
        #scroll-container {
            width: calc(100% - 22px);
            height: calc(100vh - 140px);
            overflow: auto;
            margin: 10px;
            border: 1px solid grey;
        }
    </style>
</head>

<body>
    <div id="scroll-container">
        <div id="large-container">
            <canvas id="myLineChart"></canvas>
            <!-- <div id="container"></div> -->
        </div>
    </div>
    <!-- <div style="margin-left:5%;margin-right:5%">
        <canvas id="myLineChart" style="width:100%;max-width:1840px"></canvas>
    </div> -->

    <div>
        <!-- <form action=""> -->
        <label for="html">輸入檔案</label>
        <input type="file" name="inputfile" id="inputfile" />
        <label for="html">起始位置:</label>
        <select name="chartoffsetlen" id="chartoffsetlen">
                <option value="0"> 000</option>
                <option value="200">200</option>
                <option value="400">400</option>
                <option value="600">600</option>
                <option value="800">800</option>
                <option value="1000">1000</option>
            </select>

        <label for="html">資料長度</label>
        <select name="chartmaxlen" id="chartmaxlen">
                <option value="200">200</option>
                <option selected="selected" value="400">400</option>
                <option value="600">600</option>
                <option value="800">800</option>
                <option value="1000">1000</option>
                <option value="1200">1200</option>
            </select>
        <input type="submit" value="Submit" id="inputsubmit">
        <!-- </form> -->
    </div>
    <!-- <input type="text" name="chartmaxlen" id="chartmaxlen" /> -->

    <!-- <label for="html">起始位置</label>
            <input type="text" name="chartoffsetlen" id="chartoffsetlen" />
            <label for="html">資料長度</label>
            <input type="text" name="chartmaxlen" id="chartmaxlen" /> -->
    <br />

    <!-- <input type="file" name="inputfile1" id="inputfile1">
    <br> -->
    <div>
        <pre id="output"></pre>
    </div>
    <script>
        // (function(){
        //     var data,
        //         temp,
        //         i;
        //     data = [];
        //     for (i = 0; i < 5; i += 1) {
        //         temp = {};
        //         temp['name' + i] = i;
        //         data.push(temp);
        //     }
        //     console.log(data);
        // }());

        // const a = new Array(10);
        // const b = new Array(10).fill(0);
        // a.forEach(x => console.log(x)); // does nothing
        // b.forEach(x => console.log(x)); // works as intended

        let xValues = [
            2011, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2012,
            2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014,
            2016, 2017, 2018, 2019, 2020, 2021, 2022, 2012, 2013, 2014, 2016, 2017,
            2018, 2019, 2020, 2021, 2022, 2017, 2018, 2019, 2020, 2021, 2022, 2012,
            2013, 2014, 2016, 2017, 2018, 2019, 2020, 2021, 2022,
        ];

        // let data1 = [100, 500, 600, 800, 700, 900, 1200, 850, 970, 750, 1100, 100, 500, 600, 800, 700, 900, 1200, 850, 970, 750, 1100];
        let data1 = [];
        let data2 = [98, 450, 750, 900, 650, 988, 1550, 880, 600, 800, 1300];
        let data3 = [88, 800, 450, 550, 350, 820, 620, 730, 740, 660, 669];
        let rfidarrayrec = []; //rfid data from reader, 保留 EPC + COUNT[]
        let endmaxlen = 10;
        let chartoffsetlen = 0;
        let chartmaxlen = 400;
        let mychart = 0;

        const MultiLinechartData = {
            type: "line",
            data: {
                labels: xValues,
                datasets: [{
                    label: "JavaScript Developer",
                    lineTension: 0,
                    backgroundColor: "blue",
                    borderColor: "blue",
                    data: [],
                }, {
                    label: "React Developer",
                    lineTension: 0,
                    borderColor: "green",
                    data: [],
                }, {
                    label: "Chart Js Developer",
                    lineTension: 0,
                    borderColor: "red",
                    data: [],
                }, {
                    label: "Chart Js Developer",
                    lineTension: 0,
                    borderColor: "brown",
                    data: [],
                }, ],
            },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: "TA ID 曲線圖  ",
                    },
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: "Time",
                        },
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: "Counts",
                        },
                    },
                },
            },
        };

        function getRandomColor() {
            var letters = "0123456789ABCDEF";
            var color = "#";
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        let time = 0;
        document.getElementById('inputsubmit').onclick = function() {

            let chartoffsetlenAA = document.getElementById('chartoffsetlen').value;
            let chartmaxlenAA = document.getElementById('chartmaxlen').value;
            console.log('chartoffsetlen = %s', chartoffsetlenAA);
            console.log('chartmaxlen = %s', chartmaxlenAA);

            // MultiLinechartData.data.labels = xValues;
            // console.log(MultiLinechartData.data.datasets[0].data);
            // console.log(MultiLinechartData.data.labels);

            chartoffsetlen = chartoffsetlenAA;
            chartmaxlen = chartmaxlenAA;
            // MultiLinechartData.data.labels = xValues.slice(20);
            // let mychart = document.getElementById('myLineChart')
            console.log(mychart);


            console.log('datasets.length = %s ', MultiLinechartData.data.datasets.length);
            MultiLinechartData.data.datasets.forEach(function(elem, index, arr) {
                elem.data.shift();
            });

            console.log('labels.length = %s ', MultiLinechartData.data.labels.length);
            MultiLinechartData.data.labels.shift();

            // MultiLinechartData.data.labels.forEach(function(elem, index, arr) {
            //     // console.log(elem);
            //     // elem.labels.shift();
            // });

            // mychart.update();



            // // 範例程式每次增加一筆紀錄更新 使用 ajax 方式更  chart
            // let currentTime = ++time
            // currentValue = Math.random() * 15;
            // mychart.data.labels.push(currentTime);
            // mychart.data.datasets[0].data.push(currentValue);

            // mychart.update();

            // 使用 ajax 方式更  chart
            // var ajaxCallLiveSubs = function(){
            // // endopoint
            // var url = 'https://jsonplaceholder.typicode.com/posts/1';
            // var interval = 5000;
            // var time = 0;
            // // Live Subs Charts
            // var ctx_live = document.getElementById("myChart");
            // var liveChart = new Chart(ctx_live, {
            //     type: 'line',
            //     data: {
            //         labels: [],
            //         datasets: [{
            //             data: [],
            //             borderWidth: 1,
            //             borderColor:'#00c0ef',
            //             label: 'liveCount',
            //         }]
            //     },
            //     options: {
            //         responsive: true,
            //         maintainAspectRatio: false,
            //         legend: {
            //             display: false
            //         },
            //         scales: {
            //             yAxes: [{
            //                 ticks: {
            //                     beginAtZero:true,
            //                 }
            //             }]
            //         }
            //     }
            // });

            // var doAjax = function() {
            //     $.ajax({
            //                 url: url,
            //                 success: function(){
            //                     var currentTime = ++time
            //                     var currentValue = Math.random()*1000;
            //                     liveChart.data.labels.push(currentTime);
            //                     liveChart.data.datasets[0].data.push(currentValue);

            //                     liveChart.update();

            //                 },
            //                 complete: function () {
            //                         // Schedule the next
            //                         setTimeout(doAjax, interval);
            //                 }
            //             });
            // };
            // doAjax();
            // };
            // ajaxCallLiveSubs();
        };


        document
            .getElementById("inputfile")
            .addEventListener("change", function() {
                let fr = new FileReader();

                fr.onload = function() {
                    document.getElementById("output").textContent = fr.result;
                    console.log(fr.result.length);
                    data1 = [];
                    data2 = [];
                    data3 = [];
                    xValues = [];
                    let endcount = 0;
                    let offsetcount = 0;
                    // console.log(this.result);
                    var fileContentArray = this.result.trim().split(/\r\n|\n/);
                    var lines = fileContentArray;
                    let tempstr = "";
                    let rfidarray = []; //rfid data from reader, 整理一次讀取只有RFID數據
                    console.log('chartoffsetlen = %s', chartoffsetlen);
                    console.log('chartmaxlen = %s', chartmaxlen);
                    console.log("lines.length=" + lines.length);
                    // lines.forEach(function(valstr, index, arr) {
                    for (let i = 0; i < lines.length; i++) {
                        valstr = lines[i];
                        // console.log(index + " --> "+ valstr.slice(53));
                        if (valstr.slice(53).includes("@END")) {
                            //讀取結束

                            console.log("rfidarray.length=" + rfidarray.length);
                            if (rfidarray.length > 0) {
                                endcount = 0
                                offsetcount++;
                                if (offsetcount > chartoffsetlen) {

                                    let rfidsoled = rfidsole(rfidarray);
                                    console.log(rfidsoled[0].COUNT);
                                    if (rfidsoled.length === 2) {
                                        console.log("rfidsoled[1]:" + rfidsoled[1].COUNT);
                                        data2.push(rfidsoled[1].COUNT);
                                    } else {
                                        data2.push(0);
                                    }

                                    data1.push(rfidsoled[0].COUNT);
                                    xValues.push(rfidsoled[0].TIME.slice(11));

                                }

                            } else {
                                let rfidsoled = [];
                                let rfid = {
                                    //Save RFID format
                                    EPC: "",
                                    TID: "",
                                    TIME: "",
                                    COUNT: 0,
                                };

                                // 儲  @EN  時間
                                rfid.EPC = "";
                                // console.log(rfid.EPC);
                                rfid.TIME = valstr.slice(1, 24);
                                // console.log(rfid.TIME);
                                rfidsoled.push(rfid);
                                // console.log(rfidsoled[0].COUNT);
                                data1.push(rfidsoled[0].COUNT);
                                data2.push(0);

                                if (rfidarrayrec.length > 0) {
                                    console.log("rfidsoled:");
                                    console.log(rfidsoled);
                                    xValues.push(rfidsoled[0].TIME.slice(14));
                                    rfidarrayrec.forEach(function(elem, index) {
                                        elem.Count.push(0);
                                    });
                                    console.log('rfidarrayrec[0].Count.length = %s', rfidarrayrec[0].Count.length);
                                    if (rfidarrayrec[0].Count.length > chartoffsetlen + chartmaxlen) {
                                        endcount++;
                                        console.log('break endcount = %s', endcount);
                                        // 連續看到 "@END" endmaxlen 就結束
                                        if (endcount >= endmaxlen) {
                                            // console.log('break endcount = %s', endcount);
                                            break;
                                        }
                                    }

                                }
                            }
                            rfidarray = []; //Reset array
                        } else {
                            let rfid = {
                                //Save RFID format
                                EPC: "",
                                TID: "",
                                TIME: "",
                                COUNT: 0,
                            };

                            rfid.EPC = valstr.slice(53);
                            // console.log(rfid.EPC);
                            rfid.TIME = valstr.slice(1, 24);
                            // console.log(rfid.TIME);
                            rfidarray.push(rfid);
                        }
                    }
                    console.log("myLineChart");

                    console.log(
                        "data.datasets = %s",
                        MultiLinechartData.data.datasets.length
                    );

                    rfidarrayrec.forEach(function(elem, index, arr) {
                        if (index < MultiLinechartData.data.datasets.length) {
                            MultiLinechartData.data.datasets[index].data = elem.Count;
                            MultiLinechartData.data.datasets[index].label =
                                elem.EPC.slice(0, 2) + "xx" + elem.EPC.slice(21);
                        } else {
                            let datasets = {
                                label: "Chart Js Developer",
                                lineTension: 0,
                                borderColor: getRandomColor(),
                                data: [],
                            };
                            datasets.data = elem.Count;
                            datasets.label =
                                elem.EPC.slice(0, 2) + "xx" + elem.EPC.slice(20);
                            MultiLinechartData.data.datasets.push(datasets);
                        }
                    });
                    // console.log(data1);
                    // MultiLinechartData.data.datasets[0].data = rfidarrayrec[0].Count;
                    // MultiLinechartData.data.datasets[0].label = rfidarrayrec[0].EPC;
                    // MultiLinechartData.data.datasets[1].data = rfidarrayrec[1].Count;
                    // MultiLinechartData.data.datasets[1].label = rfidarrayrec[1].EPC;
                    // MultiLinechartData.data.datasets[2].data = rfidarrayrec[2].Count;
                    // MultiLinechartData.data.datasets[2].label = rfidarrayrec[2].EPC;
                    // MultiLinechartData.data.datasets[3].data = rfidarrayrec[3].Count;
                    // MultiLinechartData.data.datasets[3].label = rfidarrayrec[3].EPC;
                    MultiLinechartData.data.labels = xValues;
                    // console.log(MultiLinechartData.data.datasets[0].data);
                    // console.log(MultiLinechartData.data.labels);
                    // let mychart = document.getElementById('myLineChart')
                    // console.log(mychart);

                    mychart = new Chart("myLineChart", MultiLinechartData);
                    console.log(mychart);

                    // console.log(MultiLinechartData);
                    // for(var line = 0; line < lines.length-1; line++){
                    //     console.log(line + " --> "+ lines[line]);
                    // }
                };
                fr.readAsText(this.files[0]);
            });

        let rfidsole = function(rfid) {
            // var len = rfid.length;
            let rfidres = [];
            let rfidarrayrecsort = [];
            let foundindex = -1;

            var sid = rfid.filter(function(ele, pos) {
                // LoggerRFID.trace('rfidsole: ' + ele.EPC + ',' + pos + ',' + rfid.indexOf(ele.EPC));
                var index;
                for (let i = 0; i < rfid.length; i++) {
                    // console.log(ele.EPC + '  :  ' + rfid[i].EPC);
                    if (ele.EPC === rfid[i].EPC) {
                        index = i;
                        // console.log('ele.EPC index= %s , pos= %s' ,index, pos);
                        break;
                    }
                }
                // console.log(index);
                let EPCNum = {
                    EPC: "",
                    TID: "",
                    TIME: "",
                    Count: [],
                };

                // console.log('rfidarrayrec:');
                // console.log(rfidarrayrec);

                let foundindexEPC = rfidarrayrec.findIndex(
                    (rank) => rank.EPC === ele.EPC
                );
                // console.log('foundindexEPC = ' + foundindexEPC);
                if (foundindexEPC < 0) {
                    EPCNum.EPC = ele.EPC;

                    if (rfidarrayrec.length > 0) {
                        EPCNum.Count = Array(rfidarrayrec[0].Count.length).fill(0);
                        console.log(
                            "Count.length= %s , EPC= %s",
                            rfidarrayrec[0].Count.length,
                            rfidarrayrec[0].EPC
                        );
                    }

                    // elem.Count.push(sid[i].COUNT);
                    rfidarrayrec.push(EPCNum);
                    // console.log(rfidarrayrec);
                    // console.log('rfidarrayrec.length = ' + rfidarrayrec.length);
                    // console.log('index= %s , pos= %s' ,index, pos);
                }
                // console.log('index= %s , pos= %s' ,index, pos);
                return index === pos; //只找第一次出現的
            });

            // console.log(sid);

            //Count
            sid.forEach((elem) => {
                for (let i = 0; i < rfid.length; i++) {
                    if (elem.EPC == rfid[i].EPC) {
                        elem.COUNT++;
                    }
                }
            });
            console.log("sid.length= " + sid.length);
            console.log(sid);
            //Count
            rfidarrayrec.forEach((elem) => {
                let i = 0;
                for (i = 0; i < sid.length; i++) {
                    if (elem.EPC == sid[i].EPC) {
                        elem.TIME = sid[i].TIME;
                        elem.Count.push(sid[i].COUNT);
                        break;
                    }
                }
                if (i === sid.length) {
                    let foundindex = rfidarrayrec.findIndex(
                        (rank) => rank.EPC === elem.EPC
                    );
                    console.log("foundindex = " + foundindex);
                    if (foundindex > -1) {
                        elem.Count.push(0);
                    }
                    console.log(elem);
                }
            });
            console.log(rfidarrayrec);
            // sid.sort(function(a, b) {
            //     return b.COUNT - a.COUNT;
            // })

            // console.trace(sid);
            // console.trace('sid.length= ' + sid.length);

            // console.log(sid);
            return sid;
        };
    </script>
</body>

</html>